= Quarkus Super-Heroes Workshop
:toc:
:toclevels: 9

* xref:../../README.adoc#setup[Setup,window=_blank]
and xref:../../README.adoc#start-project-vm[start,window=_blank]
the Quarkus VM

* xref:../../README.adoc#ssh-login[Login to the Quarkus VM,window=_blank] with your SSH client.

(The links reference my `https://github.com/buehren/learn/blob/master/jvm/quarkus/README.adoc[learn.git/jvm/quarkus/README.adoc]`)

=== Additional setup

* Run the following playbook as described in xref:../../README.adoc#run-playbook[Configure the VM with Ansible] but replace the call of `ansible-playbook` with the following:
+
[source%nowrap,bash]
----
# In the Ansible-Controller VM:

cd ~/prj/quarkus/ansible && \
ansible-playbook ~/prj/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/ansible/playbook.yml
----

=== Local build & run (DEV mode, JVM, Native, Docker)

IMPORTANT: STOP `vagrant rsync-auto` while builds are running to avoid deletion of files when changing anything on the host! +
 +
After that restart it to continue syncing changes from the host to the VM.

* In the Quarkus VM:
+
[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

./run-infrastructure.sh
./build-ui.sh


# This populates the database on start - enable this once when starting with empty database:
#export QUARKUS_HIBERNATE_ORM_DATABASE_GENERATION=drop-and-create

# Build and run in Quarkus DEV mode:
./clean-all.sh
./run-dev-all.sh
# - Now visit the displayed URLs (use 192.168.42.12 instead of localhost).
# - You can make changes in the source code, and Quarkus does a hot replace
#   either at once or on the next HTTP request!
# - Try the Dev UI:
#   http://192.168.42.12:8082/q/dev/
#   http://192.168.42.12:8085/q/dev/
./stop-dev-all.sh

export QUARKUS_HIBERNATE_ORM_DATABASE_GENERATION=""


# Build and run JARs in JVMs:
./build-jars-all.sh
./run-jars-all.sh
# Now visit the displayed URLs (use 192.168.42.12 instead of localhost)
./stop-jars-all.sh


# Build and run native executables:
./build-native-all.sh
./run-native-all.sh
# Now visit the displayed URLs (use 192.168.42.12 instead of localhost)
./stop-native-all.sh


# Build and run Docker images:
./build-docker-all.sh
./run-docker-all.sh
# Now visit the displayed URLs (use 192.168.42.12 instead of localhost)
./stop-docker-all.sh
----

==== Print Kafka messages

----
./kafkacat.sh
----

=== Google Cloud Run (like Knative)

* Guides:
** https://quarkus.io/guides/deploying-to-google-cloud#deploying-to-google-cloud-run[QUARKUS - DEPLOYING TO GOOGLE CLOUD PLATFORM (GCP)]
** https://medium.com/@alexismp/deploying-a-quarkus-app-to-google-cloud-run-c4a8ca3be526[Deploying a Quarkus native app to Cloud Run]
** https://github.com/quad-teams/quarkus-google-cloud-run[Quick Guide: Quarkus on Google Cloud Run] (includes config files and deploy scripts)
** https://github.com/ahmetb/cloud-run-faq[Google Cloud Run FAQ] (community-maintained informal knowledge base)

==== Setup

* Configure the gcloud CLI as described in `roles/gloud-cli/README.adoc` in the Ansible Configuration Project.


===== Kafka in Confluent Cloud

* https://console.cloud.google.com/marketplace/product/endpoints/payg-prod.gcpmarketplace.confluent.cloud?q=Confluent
* https://console.cloud.google.com/apis/api/payg-prod.gcpmarketplace.confluent.cloud/overview
* https://confluent.cloud/

[source%nowrap,bash]
----
curl -L --http1.1 https://cnfl.io/ccloud-cli | sudo sh -s -- -b /usr/local/bin
ccloud login --save
ccloud environment use env-xxxxx
ccloud kafka cluster use xxx-xxxxx
ccloud api-key store --resource xxx-xxxxx
ccloud api-key use XXXXXXXXXXXXXXXX --resource xxx-xxxxx

ccloud kafka topic create fights

# Add 3 lines with 1. bootstrap servers, 2. api key, 3. api secret:
vi ~/.kafka-api-key
----


===== Google Cloud SQL

* Deploy Google Cloud Resources:
+
IMPORTANT: The Google Cloud SQL instance costs! +
When no longer needed: <<delete-cloud-sql-instance>> and <<delete-cloud-project>>
+
[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

# Set environment variables: Follow the instructions in case of errors -
# until it complains about a missing database - we will create that in the next step.
source google-cloudrun-env.sh

# Allow access from this project's Google Cloud Run to Google Cloud SQL:
gcloud projects add-iam-policy-binding $GCLOUD_PROJECT_ID \
  --member serviceAccount:$GCLOUD_SERVICEACCOUNT \
  --role roles/cloudsql.client

# Create PostgreSQL database instance:
# TODO: Prepare private IP address before this (currently below) and assign it here already:
#       --network=default \
#       --no-assign-ip \
gcloud sql instances create my-database \
  --tier=db-f1-micro \
  --region=$GCLOUD_REGION \
  --assign-ip \
  --database-version=POSTGRES_13 \
  --storage-type=SSD \
  --storage-size=10GB

# Set environment variables again - now it should finish successfully:
source google-cloudrun-env.sh

# Set postgres password:
gcloud sql users set-password postgres --instance=$GCLOUD_DB_INSTANCE --prompt-for-password

# Create users:
gcloud sql users create superman --password=superman --instance=$GCLOUD_DB_INSTANCE
gcloud sql users create superbad --password=superbad --instance=$GCLOUD_DB_INSTANCE
gcloud sql users create superfight --password=superfight --instance=$GCLOUD_DB_INSTANCE

# Create databases in the postgres console:
gcloud sql connect $GCLOUD_DB_INSTANCE

# Run these commands in the postgres console:
GRANT superman TO postgres;
GRANT superbad TO postgres;
GRANT superfight TO postgres;
CREATE DATABASE heroes_database OWNER superman;
CREATE DATABASE villains_database OWNER superbad;
CREATE DATABASE fights_database OWNER superfight;
\l


# Setup private IP address for database instance
# https://cloud.google.com/sql/docs/postgres/connect-run#private-ip
# https://cloud.google.com/sql/docs/postgres/configure-private-ip
# https://cloud.google.com/sql/docs/postgres/configure-private-services-access
# https://cloud.google.com/vpc/docs/configure-serverless-vpc-access#creating_a_connector

gcloud services enable servicenetworking.googleapis.com
gcloud services enable compute.googleapis.com
gcloud services enable vpcaccess.googleapis.com

gcloud compute addresses create google-managed-services-default \
    --global \
    --purpose=VPC_PEERING \
    --addresses=192.168.100.0 \
    --prefix-length=24 \
    --network=default

gcloud services vpc-peerings connect \
    --service=servicenetworking.googleapis.com \
    --ranges=google-managed-services-default \
    --network=default

gcloud beta sql instances patch $GCLOUD_DB_INSTANCE \
  --network=default \
  --no-assign-ip

gcloud compute networks vpc-access connectors create my-vpc-connector \
  --network default \
  --range 192.168.200.0/28 \
  --region=$GCLOUD_REGION
gcloud compute networks vpc-access connectors describe my-vpc-connector \
  --region=$GCLOUD_REGION

----

* Install Google Cloud SQL Proxy for accessing the database from the local host:

** You must specify the Google Cloud SQL Connection Name on the following command line.
It is displayed as `GCLOUD_DB_CONNECTION_NAME` when running `source google-cloudrun-env.sh`.

** Run the following playbook as described in <<run-playbook>> but replace the call of `ansible-playbook`
with the following (and replace ... with the Connection Name)
+
[source%nowrap,bash]
----
# In the Ansible-Controller VM:

cd ~/prj/quarkus/ansible && \
ansible-playbook \
  ~/prj/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/ansible/install-google-cloud-sql-proxy.yml \
  --extra-vars "GCLOUD_DB_CONNECTION_NAME=..."
----

===== Google Cloud SQL database connection background [[google-cloud-sql-background]]

Google Cloud SQL can be connected in different ways:

* Public IP address - not very secure, although you can define the allowed IP addresses.

* Private IP address - requires a Google VPC setup that costs (and can it be accessed from outside?).

* By service account - requires a specialized PostgreSQL SocketFactory from Google.
** We use this option in this project. The Maven and Quarkus profiles `googlecloud` include the dependency
when building (`pom.xlm`) and activate the required configuration at runtime (`application.properties`).
** But Google's SocketFactory is not (yet?) compatible with native executables created by GraalVM
because the library uses reflection a lot -- which cannot be analyzed statically.
** Therefore, we use the GraalVM native image tracing agent for dynamic analysis
while running the service in JVM mode. This was already done, and the resulting configuration
is enabled in this project. +
-> In <<native-image-agent>> we will see how that works.

===== Populate Google Cloud SQL database from localhost

1. Set environment, start Google Cloud SQL Proxy:
+
[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

source google-cloudsql-local-env.sh
----

2. (Re-)Create database tables and insert content from `import.sql` into the Google Cloud SQL Database using Quarkus DEV mode.
+
IMPORTANT: The following code starts each service in dev-mode to delete and (re-)create
the tables and insert data into the Google Cloud SQL database. +
 +
Press CTRL+C (once) for each service after they have started and finished the inserts.
+
[source%nowrap,bash]
----
for service in $SUPERHERO_SERVICES; do
  cd $service && \
  mvn clean quarkus:dev \
      -Pgooglecloud \
      -Dquarkus.profile=googlecloud \
      -Dquarkus.hibernate-orm.database.generation=drop-and-create \
      -Ddebug=false
  cd ..
done
----

3. Stop Google Cloud SQL proxy:
+
[source%nowrap,bash]
----
sudo service cloud-sql-proxy stop
----

==== Run on localhost with access to Google Cloud SQL database and Kafka in Confluent Cloud [[run-local-with-cloud-db]]

1. Set environment, start Google Cloud SQL Proxy:
+
[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

source google-cloudsql-local-env.sh
----

2. Run services with access to Google Cloud SQL Database from localhost:
+
TIP: If the JVM mode works but the native mode produces strange exceptions,
it might help to repeat <<native-image-agent>> -- maybe a new library version
needs to be analyzed dynamically.
+
[source%nowrap,bash]
----
./stop-jars-all.sh
./stop-native-all.sh

./build-ui.sh


# To build JARs and run in JVMs:

./google-cloudrun-build-jars-all.sh && ./run-jars-all.sh
# now try the services
./stop-jars-all.sh


# To build and run native executables:

./google-cloudrun-build-native-all.sh && ./run-native-all.sh
# now try the services
./stop-native-all.sh
----

3. Stop Google Cloud SQL proxy:
+
[source%nowrap,bash]
----
sudo service cloud-sql-proxy stop
----

==== Build and deploy JARs to Google Cloud Run

IMPORTANT: STOP `vagrant rsync-auto` while builds are running to avoid deletion of files when changing anything on the host! +
 +
After that restart it to continue syncing changes from the host to the VM.

[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

# To build / deploy only certain microservices,
# run this before the build/deploy scripts
# (with the required services instead of the example):
#export SUPERHERO_SERVICES="event-statistics rest-fight"

# Build native executables for Google Cloud Run / Google Cloud SQL:
# (NOT NECESSARY if your last build was native with the googlecloudsql environment variables set)
./build-ui.sh && ./google-cloudrun-build-jars-all.sh

# Deploy to Google Cloud Run
./google-cloudrun-deploy-all.sh jvm
----

==== Configure external libraries for GraalVM with native image agent [[native-image-agent]]

#TODO#

As described in <<google-cloud-sql-background>> ....


* https://github.com/oracle/graal/blob/master/substratevm/Reflection.md
* https://github.com/oracle/graal/blob/master/substratevm/Resources.md
* https://medium.com/graalvm/introducing-the-tracing-agent-simplifying-graalvm-native-image-configuration-c3b56c486271
* https://www.graalvm.org/reference-manual/native-image/BuildConfiguration/#assisted-configuration-of-native-image-builds
* https://github.com/GoogleCloudPlatform/cloud-sql-jdbc-socket-factory/issues/217
* https://github.com/quarkusio/quarkus/pull/6634
* https://stackoverflow.com/questions/63091045/invalid-jwt-failed-audience-check-when-using-google-api-services-in-graalvm-n
* https://github.com/Taig/flog/blob/cfeff44/modules/stackdriver-http/src/main/resources/META-INF/native-image/io.taig/flog-stackdriver-http/reflect-config.json
* https://github.com/quarkusio/quarkus-quickstarts/compare/master...norrs:mysql_cloudrun_cloudsql


1. Start all services locally in JVMs as described in <<run-local-with-cloud-db>>.

2. Repeat the following for all services or all services that do not work as native executable
(`rest-hero` is used in this example):

a. Set environment variables for accessing Google Cloud SQL and Kafka in Confluent Cloud:
+
[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

source ./google-cloudsql-local-env.sh
----

b. Restart one service with the GraalVM native image agent enabled:
+
[source%nowrap,bash]
----
# Define the service to be stopped and started:
export SUPERHERO_SERVICES="rest-hero"

# Stop the service:
./stop-jars-all.sh

# Restart the service with the GraalVM native image agent enabled:
export JAVA_EXTRA_ARGS="-agentlib:native-image-agent=config-merge-dir=/home/vagrant/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/graal-native-image-agent/,config-write-period-secs=30"
./run-jars-all.sh
----

c. Now use all functionality of the current service.

d. Stop the service:
+
[source%nowrap,bash]
----
./stop-jars-all.sh
----

e. Copy the results of the GraalVM native image agent from the VM to your host:
+
[source%nowrap,bash]
----
# On host:
cd C:\.....\quarkus\quarkus-workshops\quarkus-workshop-super-heroes\super-heroes

scp vagrant@192.168.42.12:/home/vagrant/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/graal-native-image-agent/*  ./graal-native-image-agent/
----

f. Copy `reflect-config.json` and `resource-config.json`
`from graal-native-image-agent/` to `rest-hero/src/main/resources/`
(replace `rest-hero` with the current service). +
+
Fix syntax in `resource-config.json` (if still necessary, maybe works with newer GraalVM in Quarkus).
+
- TODO: Use the same directory of configuration files for all services to avoid copying to each service.
- TODO: The following interfaces were added manually - this seems to be a bug/misbehaviour of resteasy: +
org.jboss.resteasy.microprofile.config.*ConfigSource +
https://github.com/quarkusio/quarkus/issues/9086 +
https://github.com/quarkusio/quarkus/issues/5492

g. Run `vagrant rsync` on the host to copy the changes to the VM.

h. Build the current service as *native* executable and test it locally:
- `SUPERHERO_SERVICES` must still contain the current service only.
- Then follow the steps for native executable here: <<run-local-with-cloud-db>>.

i. Repeat these steps for all services (that require an updated GraalVM configuration).

3. To finally clean up and stop all services:
+
[source%nowrap,bash]
----
export SUPERHERO_SERVICES=""
export JAVA_EXTRA_ARGS=""

./stop-jars-all.sh
./stop-native-all.sh

sudo service cloud-sql-proxy stop
----

_(Maybe it would be possible to run all services at the same time with the agent enabled,
but maybe that would damage the files written to the config merge directory)._




==== Build and deploy native executables to Google Cloud Run

IMPORTANT: STOP `vagrant rsync-auto` while builds are running to avoid deletion of files when changing anything on the host! +
 +
After that restart it to continue syncing changes from the host to the VM.

[source%nowrap,bash]
----
cd ~/quarkus/quarkus-workshops/quarkus-workshop-super-heroes/super-heroes/

# To build / deploy only certain microservices,
# run this before the build/deploy scripts
# (with the required services instead of the example):
#export SUPERHERO_SERVICES="event-statistics rest-fight"

# Build native executables for Google Cloud Run / Google Cloud SQL:
# (NOT NECESSARY if your last build was native with the googlecloudsql environment variables set)
./build-ui.sh && ./google-cloudrun-build-native-all.sh

# Deploy to Google Cloud Run
./google-cloudrun-deploy-all.sh native
----

==== Send requests

#TODO#


time curl $SERVICE_REST_HERO_URL/api/heroes/random
real    0m2.244s
real    0m0.164s

rest-hero 01 native (powered by Quarkus 1.10.3.Final) started in 1.297s. Listening on: http://0.0.0.0:4242


Log explorer!

time curl $SERVICE_REST_HERO_URL/api/heroes/random
TODO


==== Delete Google Cloud SQL Instance [[delete-cloud-sql-instance]]

[source%nowrap,bash]
----
gcloud sql instances delete $GCLOUD_DB_INSTANCE
----

==== Delete Google Cloud Project [[delete-cloud-project]]

Web console


=== Knative on local Kubernetes

TODO
C:\Users\tbuehren\Documents\buehren\playground\cloud\kubernetes\knative\quarkus-in-knative-and-googlecloudrun\README.md
C:\Users\tbuehren\Documents\buehren\playground\cloud\kubernetes\knative\quarkus-in-knative-and-googlecloudrun\src\main\knative\service-native.yaml

playbook-kubernetes-knative-local.yml


== App (Flutter)

https://flutter.dev/docs/get-started/install[Install Flutter]

[source%nowrap,bash]
----
cd super-heroes/app_superheroes

# Check Flutter requirements
flutter doctor

# Switch to Beta Channel (currently required for Web target)
flutter channel beta
flutter upgrade
flutter pub get

# Build and run/debug app in Web browser
flutter build web
flutter run -d chrome

# Build and run/debug app in Android Emulator
flutter build apk
# Start Emulator in Android Studio -> Android Virtual Device Manager
flutter devices
flutter run -d emulator-5554 # use listed device name

# Build iOS App
flutter build ipa # MacOS only
----

=== Run/Debug App on attached Android Device

* Enable Developer options and USB debugging on your device. Detailed instructions are available in the https://developer.android.com/studio/debug/dev-options.html[Android documentation].
* Using a USB cable, plug your phone into your computer. If prompted on your device, authorize your computer to access your device.

[source%nowrap,bash]
----
flutter devices                  # connected Android device should be listed
flutter run -d UBV7N18A12345678  # use listed device name
----

== TO DO

done: App

TODO: App an Cloud Events / Kafka anbinden:
    1. Daten je nach Kunde!
    2. ohne eigenes Websocket?

TODO: Native Build in Cloud

TODO: User Auth (OpenID Connect?)

TODO: Contract Tests zB mit Pact

TODO: https://cloud.google.com/run/docs/authenticating/service-to-service

TODO: iOS-App bauen



done: Profil für Google Cloud Run-Konfiguration

done: Kafka

done: Scripte + Anleitung für JVM Build + Deploy auf Google Cloud Run

done: Native GraalVM configuration für rest-fight und event-statistics

done: Script für ausführung mit agentlib für Graal-Agent!

done: umstellung auf quarkus 1.11, Dev UI?

done: umstellung auf RESTEasy Reactive

done: umstellung auf PostgreSQL Reactive

TODO: (when supported by Vertx/Quarkus) PostgreSQL connection over Unix Socket in native executable (instead of private IP address of DB instance)

* https://github.com/quarkusio/quarkus/issues/12460
* https://stackoverflow.com/questions/62656445/quarkus-datasource-using-unix-socket-is-ignored

[source%nowrap]
----
DEBUG [io.qu.ve.co.ru.VertxCoreRecorder] (main) Vertx has Native Transport Enabled: false

@cescoffier and I have been looking into this. We've reproduced the issue in this small example. For epoll native transport to work in native image, it'd seem that we need to pre-register some classes/field/methdos for JNI access, plus we also need #Netty's AbstractReferenceCounted to be initialized at build time#. We haven't fully settled on a solution yet, but the example above shows one way to make it work.
https://github.com/quarkusio/quarkus/issues/10095
https://github.com/galderz/mendrugo/blob/332a8d0257dc75a8c62a560c43a8104bb99a59ea/epoll-jni-buildtime/Makefile
https://github.com/galderz/mendrugo/blob/332a8d0257dc75a8c62a560c43a8104bb99a59ea/epoll-c/Makefile

--initialize-at-run-time=$(runtime) \

runtime=io.netty.channel.epoll.Epoll,$\
io.netty.channel.epoll.EpollEventArray,$\
io.netty.channel.epoll.EpollEventLoop,$\
io.netty.channel.epoll.Native,$\
io.netty.channel.unix.Errors,$\
io.netty.channel.unix.IovArray,$\
io.netty.channel.unix.Limits,$\
io.netty.channel.unix.Socket

io.netty.channel.epoll.Epoll
     Epoll.isAvailable();
     Epoll.unavailabilityCause();
----

#TODO: commit#

TODO: simplify HeroResource.getHero() + the same for Fight and Villain (how to return "no content" header with Uni?)
TODO: simplify HeroService.updateHero() + the same for Fight and Villain

TODO: Fix local access to Google Cloud SQL: connection timed out: /192.168.100.3:5432
TODO: check/fix drop-and-create with reactive postgresql client
TODO: Check DB connection on startup

#TODO: Describe or automate required changes for local vs. cloud execution#
----
quarkus-workshop-super-heroes/super-heroes/event-statistics/src/main/resources/META-INF/resources/index.html
var top = new WebSocket("wss://" + host + "/stats/winners"); // for running in Google Cloud Run: wss // for running in local VM: ws
var team = new WebSocket("wss://" + host + "/stats/team"); // for running in Google Cloud Run: wss // for running in local VM: ws

quarkus-workshop-super-heroes/super-heroes/ui-super-heroes/src/app/shared/api/fight.service.ts
protected port = "443"; // for running in Google Cloud Run: "443"; // for running in local VM: "8082";
----


TODO: startup time google postgresql


TODO: event-statistics ui websocket timeout handling

TODO: Knative Eventing (Cloud Run Eventing) nutzen statt Kafka direkt?

TODO: Secrets (z.B. DB-Passwords, Kafka-Secret) sicher speichern (insb. nicht in variablen in cloud run)

done: Google Cloud SQL über private IP verbinden und firewall-regeln dafür einrichten?
"This guide will help you through the fourth possibility: connecting using service account."  https://github.com/quarkusio/quarkus/pull/6634/files
I don't think this is necessarily a blocker, as Cloud Run now has Serverless VPC access in beta. This means it's possible to connect directly to Cloud SQL via Private IP without the use of this library.

lokales Knative:
- TODO: workshop-Images als Services installieren
- TODO: PostgreSQL + Kafka
- TODO: Zugriff von anderen Rechnern im Netz
> http http://hello.hello.192.168.1.97.xip.io/ --headers
HTTP/1.1 404 Not Found


TODO: workshop-Images und Infrastruktur automatisieren

TODO: Deploy auf Cloud Run mit yaml + kn / kubetcl? Mit .kubeconig? Schon im alten Beispielprojekt? oder im neuen beispielprojekt unter referenzen oben?
gcloud run services replace --platform=managed <file.yaml>
https://github.com/ahmetb/cloud-run-faq#can-i-use-kubectl-to-deploy-to-cloud-run

TODO: Native Executables auch in Cloud Build bauen lassen. (Relevant für Gitops)
HIER: https://quarkus.io/guides/building-native-image#using-a-multi-stage-docker-build

TODO: Oder cloud build auch für native executable verwenden mit two-stage Dockerfile, das es irgendwo gibt

TODO: Use Dockerfile.fast-jar and ./mvnw package -Dquarkus.package.type=fast-jar available in later Quarkus versions?

TODO: Oder selbst Container bauen und hochladen: C:\Users\tbuehren\Documents\buehren\playground\cloud\kubernetes\knative\quarkus-in-knative-and-googlecloudrun\README.md


TODO: yaml statt gcloud-Kommandozeile?



TODO: Dieses Wissen zentral ablegen

TODO: Reactive API für DB + alles


TODO: Automate setup with Terraform or something similar (or even Vagrant?)

